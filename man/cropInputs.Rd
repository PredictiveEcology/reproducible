% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/postProcess.R
\name{cropInputs}
\alias{cropInputs}
\alias{cropInputs.default}
\alias{cropInputs.spatialObjects}
\alias{cropInputs.sf}
\title{Crop a \code{Spatial*} or \code{Raster*} object}
\usage{
cropInputs(x, studyArea, rasterToMatch, ...)

\method{cropInputs}{default}(x, studyArea, rasterToMatch, ...)

\method{cropInputs}{spatialObjects}(x, studyArea = NULL,
  rasterToMatch = NULL, extentToMatch = NULL, extentCRS = NULL, ...)

\method{cropInputs}{sf}(x, studyArea = NULL, rasterToMatch = NULL,
  extentToMatch = NULL, extentCRS = NULL, ...)
}
\arguments{
\item{x}{A \code{Spatial*}, \code{sf}, or \code{Raster*} object.}

\item{studyArea}{\code{SpatialPolygons*} object used for masking and possibly cropping
if no \code{rasterToMatch} is provided.
If not in same CRS, then it will be \code{spTransform}ed to
CRS of \code{x} before masking. Currently, this function will not reproject the
\code{x}. Optional in \code{postProcess}.}

\item{rasterToMatch}{Template \code{Raster*} object used for cropping (so extent should be
the extent of desired outcome) and reprojecting (including changing the
resolution and projection).
See details in \code{\link{postProcess}}.}

\item{...}{Passed to raster::crop}

\item{extentToMatch}{Optional. Can pass an extent here and a \code{crs} to
\code{extentCRS} instead of \code{rasterToMatch}. These
will override \code{rasterToMatch}, with a warning if both
passed.}

\item{extentCRS}{Optional. Can pass a \code{crs} here with an extent to
\code{extentTomatch} instead of \code{rasterToMatch}}
}
\description{
This function can be used to crop or reproject module inputs from raw data.
}
\examples{
# Add a study area to Crop and Mask to
# Create a "study area"
library(sp)
library(raster)
ow <- setwd(tempdir())

# make a SpatialPolygon
coords1 <- structure(c(-123.98, -117.1, -80.2, -100, -123.98, 60.9, 67.73, 65.58, 51.79, 60.9),
                     .Dim = c(5L, 2L))
Sr1 <- Polygon(coords1)
Srs1 <- Polygons(list(Sr1), "s1")
shpEcozone <- SpatialPolygons(list(Srs1), 1L)
crs(shpEcozone) <- "+init=epsg:4326 +proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0"

# make a "study area" that is subset of larger dataset
coords <- structure(c(-118.98, -116.1, -99.2, -106, -118.98, 59.9, 65.73, 63.58, 54.79, 59.9),
                    .Dim = c(5L, 2L))
Sr1 <- Polygon(coords)
Srs1 <- Polygons(list(Sr1), "s1")
StudyArea <- SpatialPolygons(list(Srs1), 1L)
crs(StudyArea) <- "+init=epsg:4326 +proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0"
#'
#'
##########
shpEcozonePostProcessed <- postProcess(shpEcozone, studyArea = StudyArea)
#'
# Try manually, individual pieces
shpEcozoneReprojected <- projectInputs(shpEcozone, StudyArea)
shpEcozoneCropped <- cropInputs(shpEcozone, StudyArea)
shpEcozoneClean <- fixErrors(shpEcozone)
shpEcozoneMasked <- maskInputs(shpEcozone, StudyArea)

setwd(ow)
}
\author{
Eliot McIntire, Jean Marchal, Ian Eddy, and Tati Micheletti
}
