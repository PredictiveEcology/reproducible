% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/postProcess.R
\name{postProcess}
\alias{postProcess}
\alias{postProcess.list}
\alias{postProcess.default}
\title{Generic function to post process objects}
\usage{
postProcess(x, ...)

\method{postProcess}{list}(x, ...)

\method{postProcess}{default}(x, ...)
}
\arguments{
\item{x}{A GIS object of postProcessing,
e.g., Spat* or sf*. This can be provided as a
\code{rlang::quosure} or a normal R object.}

\item{...}{Additional arguments passed to methods. For \code{spatialClasses},
these are: \code{\link[=cropTo]{cropTo()}}, \code{\link[=fixErrorsIn]{fixErrorsIn()}},
\code{\link[=projectTo]{projectTo()}}, \code{\link[=maskTo]{maskTo()}},
\code{\link[=determineFilename]{determineFilename()}}, and \code{\link[=writeTo]{writeTo()}}.
Each of these may also pass \code{...} into other functions, like
\code{\link[=writeTo]{writeTo()}}.
This might include potentially important arguments like \code{datatype},
\code{format}. Also passed to \code{terra::project},
with likely important arguments such as \code{method = "bilinear"}.
See details.}
}
\value{
A GIS file (e.g., \code{RasterLayer}, \code{SpatRaster} etc.) that has been
appropriately cropped, reprojected, masked, depending on the inputs.
}
\description{
\if{html}{\figure{lifecycle-maturing.svg}{options: alt="maturing"}}

The method for GIS objects (terra \verb{Spat*} & sf classes) will
crop, reproject, and mask, in that order.
This is a wrapper for \code{\link[=cropTo]{cropTo()}}, \code{\link[=fixErrorsIn]{fixErrorsIn()}},
\code{\link[=projectTo]{projectTo()}}, \code{\link[=maskTo]{maskTo()}} and \code{\link[=writeTo]{writeTo()}},
with a decent amount of data manipulation between these calls so that the crs match.
}
\section{Post processing sequence}{


If the \code{rasterToMatch} or \code{studyArea} are passed, then
the following sequence will occur:

\enumerate{
\item Fix errors \code{\link[=fixErrorsIn]{fixErrorsIn()}}. Currently only errors fixed are for
\code{SpatialPolygons} using \code{buffer(..., width = 0)}.
\item Crop using \code{\link[=cropTo]{cropTo()}}
\item Project using \code{\link[=projectTo]{projectTo()}}
\item Mask using \code{\link[=maskTo]{maskTo()}}
\item Determine file name \code{\link[=determineFilename]{determineFilename()}}
\item Write that file name to disk, optionally \code{\link[=writeOutputs]{writeOutputs()}}
}

NOTE: checksumming does not occur during the post-processing stage, as
there are no file downloads. To achieve fast results, wrap
\code{prepInputs} with \code{Cache}

NOTE: \code{sf} objects are still very experimental.
}

\section{Passing \code{rasterToMatch} and/or \code{studyArea}}{


Depending on which of these were passed, different things will happen to the
\code{targetFile} located at \code{filename1}.

\subsection{If \code{targetFile} is a \verb{Raster*} object:}{
\tabular{lccc}{
\tab \code{rasterToMatch} \tab \code{studyArea} \tab             Both \cr
\code{extent}     \tab Yes                  \tab   Yes        \tab \code{rasterToMatch} \cr
\code{resolution} \tab Yes                  \tab   No         \tab \code{rasterToMatch} \cr
\code{projection} \tab Yes                  \tab   No*        \tab \code{rasterToMatch}*\cr
\code{alignment}  \tab Yes                  \tab   No         \tab \code{rasterToMatch} \cr
\code{mask}       \tab No**                 \tab   Yes        \tab \code{studyArea}**   \cr
}
\itemize{
\item Can be overridden with \code{useSAcrs}.
** Will mask with \code{NA}s from \code{rasterToMatch} if \code{maskWithRTM}.
}
}

\subsection{If \code{targetFile} is a \verb{Spatial*} object:}{
\tabular{lccc}{
\tab \code{rasterToMatch} \tab \code{studyArea} \tab             Both \cr
\code{extent}     \tab Yes                  \tab   Yes        \tab \code{rasterToMatch} \cr
\code{resolution} \tab NA                   \tab   NA         \tab NA                   \cr
\code{projection} \tab Yes                  \tab   No*        \tab \code{rasterToMatch}*\cr
\code{alignment}  \tab NA                   \tab   NA         \tab NA                   \cr
\code{mask}       \tab No                   \tab   Yes        \tab \code{studyArea}     \cr
}
\itemize{
\item Can be overridden with \code{useSAcrs}
}
}
}

\examples{
# Add a study area to Crop and Mask to
# Create a "study area"
library(reproducible)
# download a zip file from internet, unzip all files, load as shapefile, Cache the call
# First time: don't know all files - prepInputs will guess, if download file is an archive,
#   then extract all files, then if there is a .shp, it will load with raster::shapefile
dPath <- file.path(tempdir(), "ecozones")
shpUrl <- "http://sis.agr.gc.ca/cansis/nsdb/ecostrat/zone/ecozone_shp.zip"

# Wrapped in a try because this particular url can be flaky
shpEcozone <- try(prepInputs(destinationPath = dPath,
                             url = shpUrl))

# Add a study area to Crop and Mask to
# Create a "study area"
coords <- structure(c(-122.98, -116.1, -99.2, -106, -122.98, 59.9, 65.73, 63.58, 54.79, 59.9),
                    .Dim = c(5L, 2L))
studyArea <- terra::vect(coords, "polygons")
terra::crs(studyArea) <- "+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0"

# With terra
if (require("terra")) {
  opts <- options("reproducible.useTerra" = TRUE)
  vectEcozone <- terra::vect(shpEcozone)

  # If input is Spatial object --> return will also be Spatial
  shpEcozonePostProcessed <- postProcessTo(shpEcozone, studyArea = studyArea)
  # Try manually, individual pieces -- Note functions are different
  shpEcozoneReprojected <- projectTo(shpEcozone, studyArea)
  shpEcozoneMasked <- maskTo(shpEcozone, studyArea)
  shpEcozoneCropped <- cropTo(shpEcozone, studyArea)

  # If input is Spat object --> return will also be Spat
  vectEcozonePostProcessed <- postProcessTo(vectEcozone, studyArea = studyArea)
  # Try manually, individual pieces -- Note functions are different
  vectEcozoneMasked <- maskTo(vectEcozone, studyArea)
  VectEcozoneReprojected <- projectTo(vectEcozone, studyArea)
  vectEcozoneCropped <- cropTo(vectEcozone, studyArea)

  # fixErrorsIn --> generally not called on its own
  shpEcozoneClean <- fixErrorsIn(vectEcozone)

  options(opts)
}

}
\seealso{
\code{prepInputs}
}
